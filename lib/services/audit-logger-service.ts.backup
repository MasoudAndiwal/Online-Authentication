import { SupabaseClient } from '@supabase/supabase-js';
import supabase from '../supabase';

/**
 * AuditAction types for tracking different system actions
 */
export type AuditAction = 
  | 'data_export'
  | 'file_upload'
  | 'file_download'
  | 'login_success'
  | 'login_failure'
  | 'password_change'
  | 'profile_update'
  | 'notification_sent';

/**
 * AuditLogEntry interface representing a single audit log record
 */
export interface AuditLogEntry {
  id?: string;
  userId: string;
  action: AuditAction;
  resource: string;
  resourceId?: string;
  metadata?: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
  timestamp?: Date;
  success: boolean;
  errorMessage?: string;
}

/**
 * AuditLogFilters for querying audit logs
 */
export interface AuditLogFilters {
  userId?: string;
  action?: AuditAction;
  startDate?: Date;
  endDate?: Date;
  success?: boolean;
  limit?: number;
  offset?: number;
}

/**
 * AuditLoggerService
 * Tracks critical system actions for compliance and security
 * Implements logging, querying, and archival of audit logs
 */
export class AuditLoggerService {
  private db: SupabaseClient;

  constructor(dbClient?: SupabaseClient) {
    this.db = dbClient || supabase;
  }

  /**
   * Log an action to the audit log
   * @param entry - Audit log entry to record
   * @returns Promise resolving to the created log entry ID
   */
  async log(entry: AuditLogEntry): Promise<string> {
    try {
      const logEntry = {
        user_id: entry.userId,
        action: entry.action,
        resource: entry.resource,
        resource_id: entry.resourceId || null,
        metadata: entry.metadata || null,
        ip_address: entry.ipAddress || null,
        user_agent: entry.userAgent || null,
        timestamp: entry.timestamp || new Date(),
        success: entry.success,
        error_message: entry.errorMessage || null,
      };

      const { data, error } = await this.db
        .from('audit_logs')
        .insert(logEntry)
        .select('id')
        .single();

      if (error) {
        console.error('Failed to create audit log:', error);
        // Don't throw - audit logging should not break application flow
        return '';
      }

      return data.id;
    } catch (error) {
      console.error('Audit log error:', error);
      // Don't throw - audit logging should not break application flow
      // But log the error for monitoring
      return '';
    }
  }

  /**
   * Query audit logs with filters
   * @param filters - Filters to apply to the query
   * @returns Promise resolving to array of audit log entries
   */
  async query(filters: AuditLogFilters): Promise<AuditLogEntry[]> {
    try {
      let query = this.db
        .from('audit_logs')
        .select('*')
        .order('timestamp', { ascending: false });

      // Apply filters
      if (filters.userId) {
        query = query.eq('user_id', filters.userId);
      }

      if (filters.action) {
        query = query.eq('action', filters.action);
      }

      if (filters.startDate) {
        query = query.gte('timestamp', filters.startDate.toISOString());
      }

      if (filters.endDate) {
        query = query.lte('timestamp', filters.endDate.toISOString());
      }

      if (filters.success !== undefined) {
        query = query.eq('success', filters.success);
      }

      // Apply pagination
      const limit = filters.limit || 100;
      const offset = filters.offset || 0;
      query = query.range(offset, offset + limit - 1);

      const { data, error } = await query;

      if (error) {
        console.error('Failed to query audit logs:', error);
        // Don't throw - return empty array on error
        return [];
      }

      // Transform database records to AuditLogEntry format
      return (data || []).map(record => ({
        id: record.id,
        userId: record.user_id,
        action: record.action as AuditAction,
        resource: record.resource,
        resourceId: record.resource_id,
        metadata: record.metadata,
        ipAddress: record.ip_address,
        userAgent: record.user_agent,
        timestamp: new Date(record.timestamp),
        success: record.success,
        errorMessage: record.error_message,
      }));
    } catch (error) {
      console.error('Audit log query error:', error);
      return [];
    }
  }

  /**
   * Get logs for a specific user
   * @param userId - User ID to get logs for
   * @param limit - Maximum number of logs to return (default: 100)
   * @returns Promise resolving to array of audit log entries
   */
  async getUserLogs(userId: string, limit: number = 100): Promise<AuditLogEntry[]> {
    return this.query({
      userId,
      limit,
    });
  }

  /**
   * Archive old logs (older than specified date)
   * @param olderThan - Date threshold for archival
   * @returns Promise resolving to number of archived records
   */
  async archiveOldLogs(olderThan: Date): Promise<number> {
    try {
      // Call the database function to archive old logs
      const { data, error } = await this.db
        .rpc('archive_old_audit_logs');

      if (error) {
        console.error('Failed to archive audit logs:', error);
        // Don't throw - return 0 archived count on error
        return 0;
      }

      // The function returns the count of archived records
      const archivedCount = data?.[0]?.archived_count || 0;
      
      console.log(`Archived ${archivedCount} audit log records older than ${olderThan.toISOString()}`);
      
      return archivedCount;
    } catch (error) {
      console.error('Audit log archival error:', error);
      return 0;
    }
  }

  /**
   * Check if audit logs exceed threshold and need archival
   * @returns Promise resolving to object with threshold status
   */
  async checkThreshold(): Promise<{ shouldArchive: boolean; totalRecords: number }> {
    try {
      const { data, error } = await this.db
        .rpc('check_audit_log_threshold');

      if (error) {
        console.error('Failed to check audit log threshold:', error);
        return { shouldArchive: false, totalRecords: 0 };
      }

      const result = data?.[0] || { should_archive: false, total_records: 0 };
      
      return {
        shouldArchive: result.should_archive,
        totalRecords: result.total_records,
      };
    } catch (error) {
      console.error('Audit log threshold check error:', error);
      return { shouldArchive: false, totalRecords: 0 };
    }
  }

  /**
   * Log a data export action
   * @param userId - User performing the export
   * @param exportFormat - Format of the export (CSV, PDF, etc.)
   * @param dateRange - Date range of exported data
   * @param ipAddress - IP address of the request
   * @param userAgent - User agent string
   * @returns Promise resolving to log entry ID
   */
  async logDataExport(
    userId: string,
    exportFormat: string,
    dateRange: { start: Date; end: Date },
    ipAddress?: string,
    userAgent?: string
  ): Promise<string> {
    return this.log({
      userId,
      action: 'data_export',
      resource: 'attendance_data',
      metadata: {
        format: exportFormat,
        dateRange: {
          start: dateRange.start.toISOString(),
          end: dateRange.end.toISOString(),
        },
      },
      ipAddress,
      userAgent,
      success: true,
    });
  }

  /**
   * Log a file upload action
   * @param userId - User uploading the file
   * @param fileName - Name of the uploaded file
   * @param fileSize - Size of the file in bytes
   * @param fileType - MIME type of the file
   * @param ipAddress - IP address of the request
   * @param userAgent - User agent string
   * @param success - Whether the upload succeeded
   * @param errorMessage - Error message if upload failed
   * @returns Promise resolving to log entry ID
   */
  async logFileUpload(
    userId: string,
    fileName: string,
    fileSize: number,
    fileType: string,
    ipAddress?: string,
    userAgent?: string,
    success: boolean = true,
    errorMessage?: string
  ): Promise<string> {
    return this.log({
      userId,
      action: 'file_upload',
      resource: 'medical_certificate',
      metadata: {
        fileName,
        fileSize,
        fileType,
      },
      ipAddress,
      userAgent,
      success,
      errorMessage,
    });
  }

  /**
   * Log an authentication failure
   * @param userId - User ID or username that failed authentication
   * @param reason - Reason for failure
   * @param ipAddress - IP address of the request
   * @param userAgent - User agent string
   * @returns Promise resolving to log entry ID
   */
  async logAuthenticationFailure(
    userId: string,
    reason: string,
    ipAddress?: string,
    userAgent?: string
  ): Promise<string> {
    return this.log({
      userId,
      action: 'login_failure',
      resource: 'authentication',
      metadata: {
        reason,
      },
      ipAddress,
      userAgent,
      success: false,
      errorMessage: reason,
    });
  }

  /**
   * Log a successful authentication
   * @param userId - User ID that successfully authenticated
   * @param ipAddress - IP address of the request
   * @param userAgent - User agent string
   * @returns Promise resolving to log entry ID
   */
  async logAuthenticationSuccess(
    userId: string,
    ipAddress?: string,
    userAgent?: string
  ): Promise<string> {
    return this.log({
      userId,
      action: 'login_success',
      resource: 'authentication',
      ipAddress,
      userAgent,
      success: true,
    });
  }

  /**
   * Get recent failed login attempts for a user
   * @param userId - User ID to check
   * @param hours - Number of hours to look back (default: 24)
   * @returns Promise resolving to array of failed login attempts
   */
  async getRecentFailedLogins(userId: string, hours: number = 24): Promise<AuditLogEntry[]> {
    const startDate = new Date();
    startDate.setHours(startDate.getHours() - hours);

    return this.query({
      userId,
      action: 'login_failure',
      startDate,
      success: false,
    });
  }

  /**
   * Get audit log statistics
   * @returns Promise resolving to statistics object
   */
  async getStatistics(): Promise<{
    totalLogs: number;
    successRate: number;
    topActions: Array<{ action: string; count: number }>;
  }> {
    try {
      // Get total count
      const { count: totalLogs, error: countError } = await this.db
        .from('audit_logs')
        .select('*', { count: 'exact', head: true });

      if (countError) {
        throw countError;
      }

      // Get success rate
      const { count: successCount, error: successError } = await this.db
        .from('audit_logs')
        .select('*', { count: 'exact', head: true })
        .eq('success', true);

      if (successError) {
        throw successError;
      }

      const successRate = totalLogs ? (successCount || 0) / totalLogs : 0;

      // Get top actions (this is a simplified version)
      const { data: actionsData, error: actionsError } = await this.db
        .from('audit_logs')
        .select('action')
        .limit(1000);

      if (actionsError) {
        throw actionsError;
      }

      // Count actions
      const actionCounts = new Map<string, number>();
      actionsData?.forEach(record => {
        const count = actionCounts.get(record.action) || 0;
        actionCounts.set(record.action, count + 1);
      });

      const topActions = Array.from(actionCounts.entries())
        .map(([action, count]) => ({ action, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 5);

      return {
        totalLogs: totalLogs || 0,
        successRate,
        topActions,
      };
    } catch (error) {
      console.error('Failed to get audit log statistics:', error);
      return {
        totalLogs: 0,
        successRate: 0,
        topActions: [],
      };
    }
  }
}

// Export singleton instance
let auditLoggerServiceInstance: AuditLoggerService | null = null;

export function getAuditLoggerService(): AuditLoggerService {
  if (!auditLoggerServiceInstance) {
    auditLoggerServiceInstance = new AuditLoggerService();
  }
  return auditLoggerServiceInstance;
}

export default AuditLoggerService;
